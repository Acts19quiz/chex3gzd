//Nodelist parsing and loading.
#DEFINE MAX_NODES 512
#DEFINE MAX_PROPS 4
#DEFINE MAX_LEARN_TIME_P1 35*30
#DEFINE MAX_LEARN_TIME_P2 35*60
#DEFINE MAX_LEARN_TIME_P3 35*90
#DEFINE MAX_LEARN_TIME 35*120 //2 nice minutes max
str NodePropStr[MAX_NODES][MAX_PROPS]; //Raw strings, have to be converted.

int NodeTID[MAX_NODES];

//Player-generated nodes, then transfered to NodeTID once finished.
int PlayNodeTID[MAX_NODES];
int CurrPNTID; //Keep track of current index on above array

//Player following-related stuff.
#DEFINE MAX_FOLLOW_NODES 16
int PlayerFollowTID[MAX_PLAYERS][MAX_FOLLOW_NODES];
int PlayerLocation[MAX_PLAYERS][3];

//Time since map start
int TSMS = -1;

int AmountOfNodes;

//Note: commented log lines are just for debugging, you can uncomment them
//if you need to.
function void ProcessNodelist (str string, bool version)
{
	//Don't bother doing anything if it's just empty
	if(strcmp(string, "") == 0) {return;}

	//Length of the string passed
	int stringlength = strlen(string);
	
	//StrMid parameters, to copy a full actor name to the StartWeapons array
	int strmidstart;
	int strmidend;
	
	//Keeps track of current character index so i can pass it to strmidstart
	//even after restarting it
	int strmidstart2;
	
	//Actor name and currently stored character
	int currentarrayindex;
	str storedchar;
	
	int curraxis;
	for(int currchar = 0; currchar <= stringlength; currchar++)
	{
		storedchar = StrMid(string, currchar, 1);//GetChar didn't work dunno why
		
		if(version == 0)
		{
			if(curraxis > AXIS_Z) {curraxis = AXIS_X;}
		}
		else
		{
			if(curraxis > NODETYPE) {curraxis = AXIS_X;}
		}
		
		//If a separator is detected, switch to next actor name and clear the
		//current string saved in memory.
		if(currchar == stringlength)
		{
			amountofnodes = currentarrayindex;
			//log(s:strmid(string, strmidstart, strmidend));
			NodePropStr[currentarrayindex][curraxis] = strmid(string, strmidstart, strmidend);
			if(version == 0)
			{
				NodePropStr[currentarrayindex][NODETYPE] = "";
				currentarrayindex++;
			}
			return;
		}
		if(StrCmp(storedchar, ";") == 0)
		{
			//log(s:strmid(string, strmidstart, strmidend));
			NodePropStr[currentarrayindex][curraxis] = strmid(string, strmidstart, strmidend);
			curraxis++;
			if( (version == 0) && (curraxis > AXIS_Z) )
			{
				NodePropStr[currentarrayindex][NODETYPE] = "";
				currentarrayindex++;
			}
			else if( (version == 1) && (curraxis > NODETYPE) )
			{
				currentarrayindex++;
			}
			
			strmidstart = strmidstart2+1; //needs to be AFTER the separator
			strmidstart2++;
			strmidend = 0;
			//log(s: "strmidstart = ",i:strmidstart);
		}
		//If not, just continue storing the actor name.
		else
		{
			strmidend++;
			strmidstart2++;
			//log(s: "strmidend = ",i:strmidend);
		}
	}
}

//I have to parse the values TWICE because you can't use strings as integers.
//Thanks, ACS limitations! 

//And more importantly, thanks to Empyre who gave me an example on how to
//join numbers. I'm so stupid i didn't imagine just 4 * 10 + 7 would 
//give me 47 :P
function int StrToInt (str string)
{
	//Don't bother doing anything if it's just empty
	if(strcmp(string, "") == 0) {return FALSE;}

	//Length of the string passed
	int stringlength = strlen(string);
	
	//Actor name and currently stored character
	int currentarrayindex;
	
	str storedchar;
	str storedcharcpy;
	
	int returnvalue;
	
	str firstchar = StrLeft(string, 1);
	for(int currchar = 0; currchar <= stringlength; currchar++)
	{
		storedchar = StrMid(string, currchar, 1);//GetChar didn't work dunno why
		storedcharcpy = storedchar;
		
		if(Strcmp(storedcharcpy, "0") == 0)
		{returnvalue = returnvalue*10;}
		
		else if(Strcmp(storedcharcpy, "1") == 0)
		{returnvalue = returnvalue*10+1;}
		
		else if(Strcmp(storedcharcpy, "2") == 0)
		{returnvalue = returnvalue*10+2;}
		
		else if(Strcmp(storedcharcpy, "3") == 0)
		{returnvalue = returnvalue*10+3;}
		
		else if(Strcmp(storedcharcpy, "4") == 0)
		{returnvalue = returnvalue*10+4;}
		
		else if(Strcmp(storedcharcpy, "5") == 0)
		{returnvalue = returnvalue*10+5;}
		
		else if(Strcmp(storedcharcpy, "6") == 0)
		{returnvalue = returnvalue*10+6;}
		
		else if(Strcmp(storedcharcpy, "7") == 0)
		{returnvalue = returnvalue*10+7;}
		
		else if(Strcmp(storedcharcpy, "8") == 0)
		{returnvalue = returnvalue*10+8;}
		
		else if(Strcmp(storedcharcpy, "9") == 0)
		{returnvalue = returnvalue*10+9;}
		
		currentarrayindex++;
	}
	if(Strcmp(firstchar, "-") == 0)
	{returnvalue = -returnvalue;}
	return returnvalue;
}

//Function from ACSUtils, licensed under the MIT License.
//Copyright (c) 2016-2017 By Alexander Korshun and the ACSUtils contributors.
//Originally called ActorDistance2D.
function int Distance(int tid1, int tid2)
{
	return VectorLength(GetActorX(tid2) - GetActorX(tid1),
	                    GetActorY(tid2) - GetActorY(tid1));
}

function void TDB_FollowNode (void)
{
	//Log(s:"Starting up TDB_FollowNode...");
	
	TakeInventory("TDBots_FollowNodeZan", 1);
	
	if(Gametype() <= GAME_NET_COOPERATIVE)
	{
		TDB_FollowPlayer();
		return;
	}
	
	if( (!GetCVAR("tdbots_usenodes")) && (!GetCVAR("tdbots_learnfromplayer")) ) {return;}
	if(CheckInventory("BotAttack")) {return;}
	
	//Log(s:"TDB_FollowNode started up!");
	
	int dist,node,newdist,retnode;
	
	dist = 384.0;
	for(int i_ = 0; i_ <= MAX_NODES; i_++)
	{
		node = NodeTID[i_];
		if(node == 0) {break;}
		newdist = Distance(0, node);
		
		if( (newdist < dist) && CheckSight(0, node, CSF_NOFAKEFLOORS))
		{
			dist = newdist;
			retnode = node;
		}
	}
	SetPointer(AAPTR_TARGET, retnode, AAPTR_DEFAULT, PTROP_NOSAFEGUARDS|PTROP_UNSAFEMASTER); //return retnode;
	GiveInventory("TDBots_FollowNodeZan", 1);
	//Log(s:"Hating node ", i:retnode);
	return;
}

function void TDB_FollowPlayer (void)
{
	//Log(s:"Starting up TDB_FollowNode...");
	
	TakeInventory("TDBots_FollowNodeZan", 1);
	
	if(!GetCVAR("tdbots_follow")) {return;}
	if(CheckInventory("BotAttack")) {return;}
	
	//Log(s:"TDB_FollowNode started up!");
	
	int dist,node,newdist,retnode;
	int pnum;
	
	dist = 2048.0;
	if(IsNetworkGame()) //if not network game then pnum will always be 0
	{
		for(int i_ = 0; i_ < MAX_PLAYERS; i_++)
		{	
			if(PlayerLocation[i_][0] + PlayerLocation[i_][1] != 0)
			{
				newdist = VectorLength(PlayerLocation[i_][0] - GetActorX(0),
									   PlayerLocation[i_][1] - GetActorY(0));
				
				if(newdist < dist)
				{
					dist = newdist;
					pnum = i_;
				}
			}
		}
	}
	
	dist = 768.0;
	for(int i = 0; i < MAX_FOLLOW_NODES; i++)
	{
		node = PlayerFollowTID[pnum][i];
		if(node == 0) {break;}
		
		if(ThingCount(0, node) > 0)
		{
			newdist = Distance(0, node);
			
			if( (newdist < dist) && CheckSight(0, node, CSF_NOFAKEFLOORS))
			{
				dist = newdist;
				retnode = node;
			}
		}
	}
	SetPointer(AAPTR_TARGET, retnode, AAPTR_DEFAULT, PTROP_NOSAFEGUARDS|PTROP_UNSAFEMASTER); //return retnode;
	GiveInventory("TDBots_FollowNodeZan", 1);
	//Log(s:"Hating node ", i:retnode);
	return;
}

function bool TDB_PlayerNoding (void)
{
	if(CurrPNTID > MAX_NODES) {return FALSE;}
	
	int node,newdist,retnode;
	int dist = 160.0;
	
	for(int i_ = 0; i_ <= MAX_NODES; i_++)
	{
		node = PlayNodeTID[i_];
		if(node == 0) {break;}
		newdist = Distance(0, node);
		
		if( (newdist < dist) && CheckSight(0, node, CSF_NOFAKEFLOORS) )
		{
			return FALSE;
		}
	}
	
	int TID = UniqueTID();
	SpawnForced("TDBots_PathNode",GetActorX(0),GetActorY(0),GetActorZ(0),TID);
	PlayNodeTID[CurrPNTID] = TID;
	CurrPNTID++;
	return TRUE;
}

function void TDB_CopyNodeTIDs (void)
{
	if(NodeTID[0] != 0) {return;}
	int node;
	for(int i; i <= MAX_NODES; i++)
	{
		node = PlayNodeTID[i];
		if(node == 0) {break;}
		NodeTID[i] = node;
	}
}

Script "TDBots_Jump" (int force) //force param for wall jumps and such in Vault
{
	if( (GetActorVelZ(0) == 0) || (force == TRUE) )
	{
		int JumpZ = GetActorProperty(0, APROP_JUMPZ);
		SetActorVelocity(0, 0, 0, JumpZ, TRUE, FALSE);
	}
}

//I couldn't figure out how to put this into the main script without it looking
//exceptionally awful, so separated it into a function.

//And oh boy does this code look messy!
bool NodelistVersion;
function str GetNodelist (bool silent)
{
	int MapLmp = StrParam(n:PRINTNAME_LEVEL);
	str cvartocheck = StrParam(s:MapLmp, s:"NodesNew");
	str StrToProcess = GetCVARString(cvartocheck);
	
	if( (StrToProcess == 0) || (strlen(StrToProcess) == 0) )
	{
		cvartocheck = StrParam(s:MapLmp, s:"Nodes");
		StrToProcess = GetCVARString(cvartocheck);
		if( (StrToProcess == 0) || (strlen(StrToProcess) == 0) )
		{
			cvartocheck = StrParam(s:MapLmp, s:"NodesNew");
			StrToProcess = StrParam(l:cvartocheck);
		
			//It's a weird check but after a lot of fiddling around i figured out
			//that this is how the L operator on StrParam works.
			//If you don't get it, basically the L operator will just return
			//the exact same LANGUAGE string identifier you gave it if that
			//identifier is undefined.
			if(strcmp(StrToProcess, cvartocheck) == 0)
			{
				cvartocheck = StrParam(s:MapLmp, s:"Nodes");
				StrToProcess = StrParam(l:cvartocheck);
				
				if(strcmp(StrToProcess, cvartocheck) == 0)
				{
					return "";
				}
				else
				{
					NodelistVersion = 0;
					if(!silent)
						Log(s:"Map-defined nodes found, loading...");
				}
			}
			else {NodelistVersion = 1; Log(s:"Map-defined nodes found, loading...");}
		}
		else
		{
			NodelistVersion = 0;
			if(!silent)
				Log(s:"Nodes found, loading...");
		}
	}
	else
	{
		NodelistVersion = 1;
		if(!silent)
			Log(s:"Nodes found, loading...");
	}
	return StrToProcess;
}

Script "TDBots_SetTarget" (int tid)
{
	SetPointer(AAPTR_TARGET, tid, AAPTR_DEFAULT, PTROP_NOSAFEGUARDS|PTROP_UNSAFEMASTER);
}

Script "TDBots_PlayerNoding" ENTER
{
	if( (!PlayerIsBot(PlayerNumber())) && (StrLen(GetNodelist(TRUE)) == 0) && (GetCVAR("tdbots_learnfromplayer")) && (Gametype() > GAME_NET_COOPERATIVE) )
	{
		while( (TSMS <= MAX_LEARN_TIME) && (GetActorProperty(0, APROP_HEALTH) > 0))
		{
			delay(16);
			TDB_PlayerNoding();
		}
	}
}

Script "TDBots_PlayerNoding2" RESPAWN
{ACS_NamedExecuteAlways("TDBots_PlayerNoding",0);}

Script "TDBots_LoadNodes" OPEN
{
	if(GetCVAR("TDBots_UseNodes") == FALSE) {terminate;}
	
	ProcessNodelist(GetNodelist(FALSE), NodelistVersion);
	delay(1);
	
	int TID,CurrArrayIndex;
	while(currarrayindex <= amountofnodes)
	{
		if(NodePropStr[CurrArrayIndex][AXIS_X])
		{
			TID = UniqueTID();
			
			/*log(s:NodePropStr[CurrArrayIndex][AXIS_X],s:" ",
				s:NodePropStr[CurrArrayIndex][AXIS_Y],s:" ",
				s:NodePropStr[CurrArrayIndex][AXIS_Z],s:" ",
				s:NodePropStr[CurrArrayIndex][NODETYPE]);
				
			log(i:StrToInt(NodePropStr[CurrArrayIndex][AXIS_X]),s:" ",
				i:StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y]),s:" ",
				i:StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z]),s:" ",
				i:StrToInt(NodePropStr[CurrArrayIndex][NODETYPE]));*/
			
			switch(StrToInt(NodePropStr[CurrArrayIndex][NODETYPE]))
			{
				case NODE_NORMAL:
				SpawnForced("TDBots_PathNode",
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])*65536, TID);
				break;
				
				case NODE_JUMP:
				SpawnForced("TDBots_JumpNode",
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])*65536, TID);
				break;
				
				case NODE_PRECISE:
				SpawnForced("TDBots_PrecisionNode",
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])*65536,
				StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])*65536, TID);
				break;
				
				default:
				log(s:"Unknown node type ", s:NodePropStr[CurrArrayIndex][NODETYPE]);
			}
			
			NodeTID[CurrArrayIndex] = TID;
			
			CurrArrayIndex++;
			delay(1);
		}
		else
		{
			break;
		}
	}
	
	if(currarrayindex != 0)
	{
		Log(i: currarrayindex, s:" Nodes fully loaded.");
		Log(s:"Nodelist version: ",i: NodelistVersion);
	}
	else if(GetCVAR("tdbots_learnfromplayer"))
	{
		while(TSMS <= MAX_LEARN_TIME)
		{
			delay(1);
			TSMS++;
			if( (TSMS == MAX_LEARN_TIME_P1) || (TSMS == MAX_LEARN_TIME_P2 ) || (TSMS == MAX_LEARN_TIME_P3) )
				TDB_CopyNodeTIDs();
		}
		TDB_CopyNodeTIDs();
	}
}